;
; PIO program to generate a suitable signal for an H bridge or half bridge.
; This will produce outputs on two consecutive pins with controllabe frequency
; and duty

; Control data in sent in a 32bit word on the FIFO:
;   16 MSB: ON counter  (T1)
;   16 LSB: OFF counter (T2)
; Period  = (2*T1 + 2*T2) * system clock (maybe add clock divider?)
; Duty = T1/(T1 + T2)

.pio_version 0 // only requires PIO version 0

.program bridgeDriverPWM
.side_set 2 opt

// First get new data from the FIFO to the osr, or if not copy the previous value back to the osr
mov x isr                  ; retrive previous value from temporary storage, also resets OSR counter to FULL    [1]
pull noblock                 ;side 0b01            ; Pull from FIFO to OSR if available, if not copies X to OSR
mov isr osr                  ; store value in isr (register for input back to the MCU)

// move osr values to the ON counter (X) and OFF counter (Y)
OUT X 16
OUT Y 16

// do on/off cycle for first outputs.  maybe use side sets?

jmp on0 side 0b01
on0:
    jmp x-- on0

jmp off0 side 0b00
off0:
    jmp y-- off0

// do on/off cycle for second outputs  ADD SIDE SETS

mov osr isr          ; retrive previous value from temporary storage, also resets OSR counter to FULL    [1]

// move osr values to the ON counter (X) and OFF counter (Y)
OUT X 16
OUT Y 16

// do on/off cycle for first outputs  ADD SIDE SETS

jmp on1 side 0b10
on1:
    jmp x-- on1

jmp off1 side 0b00
off1:
    jmp y-- off1


% c-sdk {
static inline void bridgeDriverPWM_program_init(PIO pio, uint sm, uint offset, uint pin) {
   pio_gpio_init(pio, pin);
   pio_gpio_init(pio, pin+1);
   pio_sm_set_consecutive_pindirs(pio, sm, pin, 2, true);
   pio_sm_config c = bridgeDriverPWM_program_get_default_config(offset);
   sm_config_set_sideset_pins(&c, pin);
   pio_sm_init(pio, sm, offset, &c);
}
%}
