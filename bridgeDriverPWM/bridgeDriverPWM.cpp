#include "bridgeDriverPWM.h"
#include "bridgeDriverPWM.pio.h"      //header generated by CMakeLists RENAME!

//TODO: add function to delete programs and free up PIO units


bridgeDriverPWM::bridgeDriverPWM(uint pin, uint32_t initial_frequency, uint32_t initial_duty, PIO pio)  {
    // load program onto pio and activate state machine sm0
    // this pio program requires 2 pins - specify the first one, next consecutive one will be used
    // and will have the inverse signal on it
    _pio = pio;   
    _pin[0] = pin;
    _offset = pio_add_program(_pio, &bridgeDriverPWM_program);
    uint channel=0;  // this is the first SM on the PIO, extra channels are added using addChannel()
    _n_channels = 1;
    bridgeDriverPWM_program_init(_pio, channel, _offset, _pin[0]);
    setFreqDuty(channel, initial_frequency, initial_duty);
}

bool bridgeDriverPWM::addChannel(uint pin, uint32_t initial_frequency, uint32_t initial_duty) {
   //add additional square wave generators to other state machines within the PIO
   // ensure the pins do not overlap the pins from other channels 
   hard_assert (_n_channels <= 3);    // max 4 state machines (channels) per PIO
   uint new_channel = _n_channels;  
   pio_sm_claim(_pio, new_channel);   // put new channel on next available state machine
   bridgeDriverPWM_program_init(_pio, new_channel, _offset, pin);
   //setFreqDuty(new_channel, initial_frequency, initial_duty);
   _pin[new_channel] = pin;
   _n_channels ++;       // total number of state machines (channels) used on this PIO device
   return true;
}

void bridgeDriverPWM::setTimingRegister(uint channel, uint32_t regval)  {
    // sends the timing register using the FIFO register. 
    pio_sm_put_blocking(_pio, channel, regval); 
    _regval[channel] = regval;
}

uint32_t bridgeDriverPWM::_calculateTimingRegisters(uint32_t freq, uint32_t duty) {
    // calculates the timing register values based on the system clock and requested frequency and duty
    // First calculate period
    uint32_t period = SYS_CLK_HZ / (2 * freq);    // period of half-cycle in clock cycles 
    //XXXTODO add in range checking for freq
    // then get the on and off times from this
    uint32_t ontime = (period * duty) / 1000;
    uint32_t T1 = ontime - 3;  // see bridgeDriverPWM.pio for details 
    uint32_t T2 = period - ontime - 3;
    uint32_t regval = (T2<<16) | T1;
    return regval;
}

uint32_t bridgeDriverPWM::setFrequency(uint channel, uint32_t frequency) {
    // calculate the timing values 
    if (frequency == 0) {
        // impossible frequency - just disable the generator and set timing register to 0
        enable(channel, false);
        setTimingRegister(channel, 0);
        //XXXTODO possible set an error here? perhaps have a _status variable?
        return frequency;   //XXXFIXME calculate the true freq
    } else {
        uint32_t regval = _calculateTimingRegisters(frequency, _requested_duty[channel]);
        _requested_freq[channel] = frequency;
        setTimingRegister(channel, regval); 
        return frequency;  
    } 
}

uint32_t bridgeDriverPWM::setDuty(uint channel, uint duty1000) {
    if (duty1000 == 0) {
    // Just turn off, but leave the frequency unchanged 
    enable(channel, false); 
    }
    uint32_t regval = _calculateTimingRegisters(_requested_freq[channel], duty1000);
    _requested_duty[channel] = duty1000;
    setTimingRegister(channel, regval); 
    return 0;
}

bool bridgeDriverPWM::setFreqDuty(uint channel, uint32_t frequency, uint32_t duty1000)
{
    bool retval = false;
    if ((frequency == 0) || (duty1000 == 0)) {
        enable(channel, false);
        if (frequency == 0) {
            // impossible frequency - just disable the generator and set timing register to 0
            setTimingRegister(channel, 0);
        }
    } else {
        uint32_t regval = _calculateTimingRegisters(frequency, duty1000);
        setTimingRegister(channel, regval); 
        _requested_freq[channel] = frequency;
        _requested_duty[channel] = duty1000;
        retval = true;
    }
    return retval;
}

void bridgeDriverPWM::enable(uint channel, bool state) {
    if (state==true) {
        // enable the output
        pio_sm_set_enabled(_pio, channel, true);
    } else {
        // disable the output and set low.
        pio_sm_set_enabled(_pio, channel, false);
        //. see https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/hardware_pio/include/hardware/pio.h
        //void pio_sm_set_pins64(PIO pio, uint sm, uint64_t pin_values);

        pio_sm_set_pins(_pio, channel, 0);
        //pio_sm_set_pins(_pio, _pin[channel]+1, 0);
        
    }
}

void bridgeDriverPWM::allOff() {
    // disable all channels, and set all outputs low, including the inverse pins
    for (uint channel=0; channel<_n_channels; channel++) {
        enable(channel, false);
    }
}


