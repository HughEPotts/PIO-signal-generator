#include <algorithm>  // needed fro min, max
#include "bridgeDriverPWM.h"

#include "bridgeDriverPWM.pio.h" //header generated by CMakeLists RENAME!

// TODO: add function to delete programs and free up PIO units
// Note: for VS studio coed formatting see:
// https://stackoverflow.com/questions/45823734/visual-studio-code-formatting-for
// and
// https://zamhuang.medium.com/vscode-how-to-customize-c-s-coding-style-in-vscode-ad16d87e93bf
// serch for "Clang_format_fallback" in settings

// Setting timing regsters:
// Correct operation:
//   - Set freq and duty to best approximation (freq and duty always rounded up)
//   - Set _requested_freq and _requested_duty to the values requested
//   - Set _actual_freq and _actual_duty to the calculated values
//   - if Duty == 0, set duty to minimum ?disable output?
//   - Return PWM_OK
// Dealing with bad input
// 1) Freq too high: Set to maximum freq (bridgeDriverPWM.max_freq) and appropriate duty, return PWM_FREQ_TOO_HIGH
// 2) Freq too low:  Set to minimum freq (bridgeDriverPWM.min_freq) and appropriate duty, return PWM_FREQ_TOO_LOW
// 3) Duty > 1000: Set to max duty, return PWM_DUTY_TOO_HIGH

//

bridgeDriverPWM::bridgeDriverPWM(uint pin, uint32_t initial_frequency, uint32_t initial_duty, PIO pio) {
    // load program onto pio and activate state machine sm0
    // this pio program requires 2 pins - specify the first one, next
    // consecutive one will be used and will have the inverse signal on it
    // intialse all class variables for all channels

    for (int i=0; i<4; i++) {
        _requested_freq[i] = 0;
        _requested_duty[i] = 0;
        _regval[i] = 0;
        _status[i] = PWM_NOT_INITIALISED;
    }

    _pio = pio;
    _pin[0] = pin;
    _offset = pio_add_program(_pio, &bridgeDriverPWM_program);
    uint channel = 0; // this is the first SM on the PIO, extra channels are
                      // added using addChannel()
    _n_channels = 1;
    bridgeDriverPWM_program_init(_pio, channel, _offset, _pin[0]);
    setFreqDuty(channel, initial_frequency, initial_duty);
    _status[0] = PWM_OK;
}

bool bridgeDriverPWM::addChannel(uint pin, uint32_t initial_frequency, uint32_t initial_duty) {
    // add additional square wave generators to other state machines within the PIO
    // ensure the pins do not overlap the pins from other channels
    hard_assert(_n_channels <= 3); // max 4 state machines (channels) per PIO
    uint new_channel = _n_channels;
    pio_sm_claim(_pio,
                 new_channel); // put new channel on next available state machine
    bridgeDriverPWM_program_init(_pio, new_channel, _offset, pin);
    // setFreqDuty(new_channel, initial_frequency, initial_duty);
    _pin[new_channel] = pin;
    _n_channels++; // total number of state machines (channels) used on this
                   // PIO device
    _status[new_channel] = PWM_NOT_INITIALISED;
    return true;
}

pwm_error_t bridgeDriverPWM::setFrequency(uint channel, uint32_t frequency) {
    return setFreqDuty(channel, frequency, _requested_duty[channel]);
}

pwm_error_t bridgeDriverPWM::setDuty(uint channel, uint duty1000) {
    return setFreqDuty(channel, _requested_freq[channel], duty1000);
}

pwm_error_t bridgeDriverPWM::setFreqDuty(uint channel, uint32_t frequency, uint32_t duty1000) {
    _requested_freq[channel] = frequency;
    _requested_duty[channel] = duty1000;
    uint32_t set_freq = frequency;
    uint32_t set_duty = duty1000;

    // calculate the timing values
    // both the frequency and the duty can have errors. If there are erros in both return the frequency error
    pwm_error_t retval = PWM_OK;
    if (channel >= _n_channels) {
        // channel has not been set up
        return PWM_NOT_INITIALISED;
    }

    if (duty1000 > 1000) {
        set_duty = 1000;
        retval = PWM_DUTY_TOO_HIGH;
    };

    if (duty1000 == 0) {
        set_duty = 0;
        retval = PWM_DUTY_TOO_LOW;

    };

    if (frequency < min_freq) {
        // set to minimum frequency, and return error
        retval = PWM_FREQ_TOO_LOW;
        set_freq = min_freq;
    }
    if (frequency > max_freq) {
        retval = PWM_FREQ_TOO_HIGH;
        set_freq = max_freq;
    }
    uint32_t regval = _calculateTimingRegisters(set_freq, set_duty);
    _regval[channel] = regval;

    setTimingRegister(channel, regval);
    _status[channel] = retval;
    return retval;
}

void bridgeDriverPWM::setTimingRegister(uint channel, uint32_t regval) {
    // sends the timing register using the FIFO register.
    pio_sm_put_blocking(_pio, channel, regval);
    _regval[channel] = regval;
}

void bridgeDriverPWM::setTimingRegister(uint channel, uint16_t on_time, uint16_t off_time) {
    // assembles the timing register fro the on_time and off_time (in clock counts)
    // then sends the timing register using the FIFO register.
    // min value for on_time and off_time = 3 counts
    if (on_time < 3) {
        on_time = 3;
        _status[channel] = PWM_SET_TR_INVALID_COUNTS;
    };
    if (off_time < 3) {
        off_time = 3;
        _status[channel] = PWM_SET_TR_INVALID_COUNTS;
    }
    uint32_t regval = (off_time - 3) << 16 | (on_time - 3); 
    setTimingRegister(channel, regval);
};

uint32_t bridgeDriverPWM::getFrequency(uint channel) {
    // returns the actual frequency (rounded to nearest Hz), calculated from the register value
    uint32_t ontime = (_regval[channel] | 0xffff) + 3;
    uint32_t offtime = ((_regval[channel] >> 16) | 0xffff) + 3;
    return SYS_CLK_HZ / (2 * (ontime + offtime));
}

uint32_t bridgeDriverPWM::getDuty(uint channel) {
    // returns the actual frequency (rounded to nearest Hz), calculated from the register value
    uint32_t ontime = (_regval[channel] | 0xffff) + 3;
    uint32_t offtime = ((_regval[channel] >> 16) | 0xffff) + 3;
    return (ontime * 1000) / offtime;
}

void bridgeDriverPWM::enable(uint channel, bool state) {
    if (state == true) {
        // enable the output
        pio_sm_set_enabled(_pio, channel, true);
    } else {
        // disable the output and set both outputs low.
        pio_sm_set_enabled(_pio, channel, false);
        pio_sm_set_pins(_pio, channel, 0);
    }
}

void bridgeDriverPWM::allOff() {
    // disable all channels, and set all outputs low, including the inverse pins
    for (uint channel = 0; channel < _n_channels; channel++) {
        enable(channel, false);
    }
}

uint32_t bridgeDriverPWM::_calculateTimingRegisters(uint32_t freq, uint32_t duty) {
    // calculates the timing register values based on the system clock and
    // requested frequency and duty. First calculate period
    uint32_t period = SYS_CLK_HZ / (2 * freq); // period of half-cycle in clock cycles
    // minimum on_time and off_time are 3 cycles (see bridgeDriverPWM.pio for details), so need to be careful at very high and low duties
    uint32_t ontime = (period * duty) / 1000;
    // at 100% duty ontime = period - 3, offtime should be zero  
    // at low duty min value of the ontime is 3 cycles (T1=0)
    if (ontime > period-3) ontime = period -3;
    if (ontime < 3) ontime = 3;
    
    uint32_t T1 = ontime - 3;                 // this gives the correct on_time in clock cycles 
    uint32_t T2 = period - ontime - 3;
    
    uint32_t regval = (T2 << 16) | T1;
    return regval;
}